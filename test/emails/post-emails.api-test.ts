import { IncorrectAuthArg, withClientAuthenticationTests } from '@ukef-test/common-tests/client-authentication-api-tests';
import { withEmailFieldValidationApiTests } from '@ukef-test/common-tests/request-field-validation-api-tests/email-address-field-validation-api-tests';
import { withStringFieldValidationApiTests } from '@ukef-test/common-tests/request-field-validation-api-tests/string-field-validation-api-tests';
import { Api } from '@ukef-test/support/api';
import { PostEmailsGenerator } from '@ukef-test/support/generator/post-emails-generator';
import { RandomValueGenerator } from '@ukef-test/support/generator/random-value-generator';
import { AxiosError, AxiosResponse } from 'axios';
import escapeStringRegexp from 'escape-string-regexp';
import nock from 'nock';
import { NotifyClient } from 'notifications-node-client';

describe('POST /emails', () => {
  const valueGenerator = new RandomValueGenerator();

  let api: Api;
  let sendEmailMethodMock;

  const govUkNotifyKey = valueGenerator.string({ length: 10 });
  const { mdmPath, requests, postEmailsResponse } = new PostEmailsGenerator(valueGenerator).generate({
    numberToGenerate: 1,
  });
  const errorMessage = valueGenerator.sentence();

  const generateNotifyError = (status: number, message?: string | null) => {
    const response = {
      data: {
        status_code: status,
        errors: [
          {
            error: valueGenerator.word(),
            message,
          },
        ],
      },
    } as AxiosResponse;
    return new AxiosError(`Request failed with status code ${status}`, status.toString(), null, null, response);
  };

  beforeAll(async () => {
    api = await Api.create();
  });

  beforeEach(() => {
    jest.resetAllMocks();
    sendEmailMethodMock = jest.spyOn(NotifyClient.prototype, 'sendEmail').mockImplementation(() => Promise.resolve(postEmailsResponse[0][0]));
  });

  afterAll(async () => {
    await api.destroy();
  });

  afterEach(() => {
    nock.abortPendingRequests();
    nock.cleanAll();
  });

  withClientAuthenticationTests({
    givenTheRequestWouldOtherwiseSucceed: () => {
      jest.spyOn(NotifyClient.prototype, 'sendEmail').mockImplementation(() => Promise.resolve(postEmailsResponse[0][0]));
    },
    makeRequestWithoutAuth: (incorrectAuth?: IncorrectAuthArg) => api.postWithoutAuth(mdmPath, requests, incorrectAuth?.headerName, incorrectAuth?.headerValue),
  });

  it('returns a 201 response with receipt for sent email', async () => {
    const { status, body } = await api.post(mdmPath, requests, { govUkNotifyKey });

    expect(status).toBe(201);
    expect(body).toStrictEqual(postEmailsResponse[0][0]);
  });

  it('calls NotifyClient.sendEmail', async () => {
    await api.post(mdmPath, requests, { govUkNotifyKey });

    expect(sendEmailMethodMock).toHaveBeenCalledWith(
      requests[0].templateId,
      requests[0].sendToEmailAddress,
      expect.objectContaining({
        personalisation: requests[0].personalisation,
        // Check if autogenerated `reference` matches expected pattern.
        // eslint-disable-next-line security/detect-non-literal-regexp
        reference: expect.stringMatching(new RegExp(`^${escapeStringRegexp(requests[0].templateId)}-\\d*$`)),
      }),
    );
  });

  it('calls NotifyClient.sendEmail with custom reference', async () => {
    const customReference = valueGenerator.string({ length: 10 });

    await api.post(mdmPath, [{ ...requests[0], reference: customReference }], { govUkNotifyKey });

    expect(sendEmailMethodMock).toHaveBeenCalledWith(requests[0].templateId, requests[0].sendToEmailAddress, {
      personalisation: requests[0].personalisation,
      reference: customReference,
    });
  });

  it('returns a 400 response if header `govUkNotifyKey` is missing', async () => {
    const { status, body } = await api.post(mdmPath, requests);

    expect(status).toBe(400);
    expect(body).toStrictEqual({ error: 'Bad Request', message: ['govUkNotifyKey header is required'], statusCode: 400 });
  });

  it.each([
    {
      error: 'Bad Request',
      expectedStatus: 400,
    },
    {
      error: 'Unauthorized',
      expectedStatus: 401,
    },
    {
      error: 'Forbidden',
      expectedStatus: 403,
    },
  ])('returns a $expectedStatus response if notify client response with status $expectedStatus', async ({ error, expectedStatus }) => {
    jest.mocked(sendEmailMethodMock).mockImplementation(() => Promise.reject(generateNotifyError(expectedStatus, errorMessage)));

    const { status, body } = await api.post(mdmPath, requests, { govUkNotifyKey });

    expect(status).toBe(expectedStatus);
    expect(body).toMatchObject({
      error,
      message: expect.arrayContaining([errorMessage]),
      statusCode: expectedStatus,
    });
  });

  it('returns a 500 response if notify client response with status 500', async () => {
    jest.mocked(sendEmailMethodMock).mockImplementation(() => Promise.reject(generateNotifyError(500)));

    const { status, body } = await api.post(mdmPath, requests, { govUkNotifyKey });

    expect(status).toBe(500);
    expect(body).toStrictEqual({
      statusCode: 500,
      message: 'Internal server error',
    });
  });

  describe('field validation', () => {
    withStringFieldValidationApiTests({
      fieldName: 'templateId',
      minLength: 1,
      maxLength: 40,
      required: true,
      generateFieldValueOfLength: (length: number) => valueGenerator.string({ length }),
      validRequestBody: requests,
      makeRequest: (body) => api.post(mdmPath, body, { govUkNotifyKey }),
      givenAnyRequestBodyWouldSucceed: () => {
        sendEmailMethodMock = jest.spyOn(NotifyClient.prototype, 'sendEmail').mockImplementation(() => Promise.resolve(postEmailsResponse[0][0]));
      },
    });

    withEmailFieldValidationApiTests({
      fieldName: 'sendToEmailAddress',
      minLength: 7,
      maxLength: 60,
      required: true,
      generateFieldValueOfLength: (length: number) => valueGenerator.email({ length }),
      validRequestBody: requests,
      makeRequest: (body) => api.post(mdmPath, body, { govUkNotifyKey }),
      givenAnyRequestBodyWouldSucceed: () => {
        sendEmailMethodMock = jest.spyOn(NotifyClient.prototype, 'sendEmail').mockImplementation(() => Promise.resolve(postEmailsResponse[0][0]));
      },
    });

    withStringFieldValidationApiTests({
      fieldName: 'reference',
      minLength: 1,
      maxLength: 60,
      required: false,
      generateFieldValueOfLength: (length: number) => valueGenerator.string({ length }),
      validRequestBody: requests,
      makeRequest: (body) => api.post(mdmPath, body, { govUkNotifyKey }),
      givenAnyRequestBodyWouldSucceed: () => {
        sendEmailMethodMock = jest.spyOn(NotifyClient.prototype, 'sendEmail').mockImplementation(() => Promise.resolve(postEmailsResponse[0][0]));
      },
    });

    it('returns a 201 response if optional object field personalisation is not present', async () => {
      const [{ personalisation: _personalisation, ...requestWithoutPersonalisation }] = requests;

      const { status, body } = await api.post(mdmPath, [requestWithoutPersonalisation], { govUkNotifyKey });

      expect(status).toBe(201);
      expect(body).toStrictEqual(postEmailsResponse[0][0]);
    });

    it('returns a 400 response if object field personalisation is string', async () => {
      const requestWithPersonalisationString = { ...requests[0], personalisation: '' };

      const { status, body } = await api.post(mdmPath, [requestWithPersonalisationString], { govUkNotifyKey });

      expect(status).toBe(400);
      expect(body).toStrictEqual({ error: 'Bad Request', message: ['personalisation must be an object'], statusCode: 400 });
    });

    it('returns a 201 response if object field personalisation is null', async () => {
      const requestWithPersonalisationString = { ...requests[0], personalisation: null };

      const { status, body } = await api.post(mdmPath, [requestWithPersonalisationString], { govUkNotifyKey });

      expect(status).toBe(400);
      expect(body).toStrictEqual(postEmailsResponse[0][0]);
    });
  });
});
